#' Smooth Predictions Function
#'
#' This function generates smooth predictions from a given GAM model object.
#'
#' @param model A GAM object. The model must be of class "gam".
#' @param dose_col A character string specifying the name of the dose column in the input data frame.
#' @param sample_col A character string specifying the name of the sample column in the input data frame.
#' @param covariates_cols A character string or a vector of character strings specifying the name(s) of the covariate column(s) in the input data frame.
#' @param long_df A data frame containing the input data.
#'
#' @return A list with the smooth predictions from the GAM model.
#'
#' @importFrom mgcv predict.gam
#' @importFrom utils globalVariables
#' @importFrom stats predict
#'
#' @examples
#' \dontrun{
#' data("mtcars")
#' model <- mgcv::gam(mpg ~ s(hp), data = mtcars)
#' predictions <- smooth_predictions(model = model,
#'                                   dose_col = "hp",
#'                                   sample_col = "mpg",
#'                                   covariates_cols = "",
#'                                   long_df = mtcars)
#' }
#'
#' @export
smooth_predictions <- function(model, long_df, dose_col="dose", sample_col="sample", covariates_cols="") {
  # Check if model is a GAM
  if (!inherits(model, "gam")) {
    stop("model must be a GAM object")
  }

  # # Get names of all covariates
  # covariates <- names(model$model)[!grepl("^s\\(", names(model$model))]
  #
  # # If covariates_cols is not empty, add covariates to covariates
  # if (covariates_cols != "") {
  #   covariates <- c(covariates, covariates_cols)
  # }


  # Generate predictions with confidence intervals
  new_data <- expand.grid(
    dose = seq(min(long_df[dose_col]), max(long_df[dose_col]), length.out = 50),
    gene = unique(long_df$gene),
    sample = unique(long_df$sample)
  )

  colnames(new_data) <- c(dose_col,"gene","sample")
  predictions <- predict(model, newdata = new_data, se.fit = TRUE)
  predictions <- cbind(new_data, predictions)
  # Return smooth predictions
  return(predictions)
}



#' Fit Generalized Additive Model (GAM) and Compute AIC and BIC
#'
#' This function fits a GAM to the provided data using the specified formula.
#' The aim is to model all the genes from a specified pathway to check the effects of a dose.
#' The model is fitted using the maximum likelihood (ML) method, as this allows for the comparison of models with random effects.
#' If fitting fails, NA is returned.
#'
#' @param formula A formula for the GAM model generated by the `create_gamm_formula` function.
#' @param data A data frame (in long format) containing the data to be modeled. The data frame should include
#' columns for dose, gene (or metabolite), and, if 'rnaseq' is specified, an offset. Other covariates may also be present.
#'
#' @return A GAM model if fitting is successful; NA otherwise.
#'
#' @importFrom mgcv bam
#' @importFrom stats formula
#' @importFrom utils globalVariables
#'
#' @examples
#' \dontrun{
#' data("mtcars")
#' # Generate a suitable formula for the GAM model using `create_gamm_formula`
#' formula <- create_gamm_formula(response = "mpg",
#'                                fixed_effects = "hp",
#'                                random_effects = "cyl",
#'                                model_type = "base")
#' model <- fit_gam(formula = formula, data = mtcars)
#' }
#'
#' @export
fit_gam <- function(formula, data) {
  #data$start_event <- data$dose == 0
  tryCatch(
    {
      gam_model <- bam(as.formula(formula), data = data, method = "ML")
      return(gam_model)
    },
    error = function(e) {
      return(NA)
    }
  )
}


#' Create Generalized Additive Mixed Model (GAMM) Formula
#'
#' This function generates a formula for a GAMM, given response and effect variables, and the model type.
#' It allows for the specification of 'base', 'linear', or 'cubic' model types. The main goal is to
#' compare the 'cubic' model with the 'base' model to evaluate if the fixed effect (in this case 'dose')
#' is significant.
#'
#' @param response A string specifying the response variable in the model.
#' @param fixed_effects A string or a vector of strings specifying the fixed effects in the model.
#' @param random_effects A string or a vector of strings specifying the random effects in the model.
#' @param covariates A string or a vector of strings specifying any covariates to be included in the model. Default is an empty vector.
#' @param model_type A string specifying the type of the model. Can be 'base', 'linear', or 'cubic'. Default is 'base'.
#'
#' @return A string representing the formula for the GAMM.
#'
#' @examples
#' \dontrun{
#' # Create a base formula
#' base_formula <- create_gamm_formula(response = "counts",
#'                                     fixed_effects = "dose",
#'                                     random_effects = "gene",
#'                                     model_type = "base")
#' # Create a linear formula
#' linear_formula <- create_gamm_formula(response = "counts",
#'                                       fixed_effects = "dose",
#'                                       random_effects = "gene",
#'                                       model_type = "linear")
#' # Create a cubic formula
#' cubic_formula <- create_gamm_formula(response = "counts",
#'                                      fixed_effects = "dose",
#'                                      random_effects = "gene",
#'                                      model_type = "cubic")
#' }
#' @export
create_gamm_formula <- function(response, fixed_effects, random_effects, covariates = c(), model_type = "base") {
  # Format the random effects for intercept and slope using 're' basis,
  # indicating that these are random effects.
  format_random_effects_intercept <- paste0("s(", random_effects, ", bs = 're')")
  format_random_effects_slope <- paste0("s(",random_effects,",", fixed_effects, ", bs = 're')")

  # Format the fixed effects using 'cr' basis for cubic regression splines,
  # and specify the maximum number of knots to be 7.
  format_fixed_effects <- paste0("s(", fixed_effects, ", bs = 'cr', k = 7)")

  # Define the base formula by combining the response variable, random effects intercept,
  # and covariates if they are specified.
  base_formula <- paste(response, "~",
                        paste(format_random_effects_intercept, collapse = " + "),
                        if (length(covariates) > 0) paste(covariates, collapse = " + "))

  # Return the respective formula based on the specified model type
  if (model_type == "base") {
    return(base_formula)
  } else if (model_type == "linear") {
    # For a linear model, include the fixed effects and random effects intercept.
    linear_formula <- paste(response, "~ ", paste(fixed_effects, collapse = " + "), "+",
                            paste(format_random_effects_intercept, collapse = " + "),
                            if (length(covariates) > 0) paste(covariates, collapse = " + "))
    return(linear_formula)
  } else if (model_type == "cubic") {
    # For a cubic model, include the fixed effects, random effects intercept,
    # cubic regression splines for the fixed effects, and the interaction term between
    # the fixed effects and the random effects slope.
    cubic_formula <- paste(response, "~ ", paste(fixed_effects, collapse = " + "), "+",
                           paste(format_random_effects_intercept, collapse = " + "), "+", paste(format_fixed_effects, collapse = " + "),
                           "+", paste(format_random_effects_slope, collapse = " + ") ,
                           if (length(covariates) > 0) paste(covariates, collapse = " + "))
    return(cubic_formula)
  } else {
    # If the model type is not recognized, stop the function execution and return an error message.
    stop("Invalid model type. Available options: 'base', 'linear', 'cubic'")
  }
}


#' Compute metrics for a given model
#'
#' This function computes the AIC, BIC and edf metrics for a given model. If the model is not a list, it will return NA for all the metrics.
#'
#' @param model A model object or a list. If it is a model, the function computes the metrics. If it's not a list, the function returns NA for all the metrics.
#'
#' @return A list containing the AIC, BIC and edf of the model. If the model parameter is not a list, the function will return NA for all metrics.
#' @examples
#' # Create a linear model
#' data(mtcars)
#' model <- lm(mpg ~ hp, data = mtcars)
#'
#' # Compute metrics
#' compute_metrics(model)
#' @export
compute_metrics <- function(model) {
  if (is.list(model)) {
    return(list(
      AIC = AIC(model),
      BIC = BIC(model),
      edf = sum(influence(model))
    ))
  } else {
    return(list(
      AIC = NA,
      BIC = NA,
      edf = NA
    ))
  }
}

